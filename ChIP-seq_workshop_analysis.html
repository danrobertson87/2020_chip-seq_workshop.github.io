<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Analysis</title>

<script src="site_libs/header-attrs-2.24/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/yeti.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="site_libs/pagedtable-1.1/js/pagedtable.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>






<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Home</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="ChIP-seq_workshop_intro.html">Getting Started</a>
</li>
<li>
  <a href="ChIP-seq_workshop_QC.html">Quality Control</a>
</li>
<li>
  <a href="ChIP-seq_workshop_map.html">Mapping and Filtering</a>
</li>
<li>
  <a href="ChIP-seq_workshop_visualisation.html">Visualisation</a>
</li>
<li>
  <a href="ChIP-seq_workshop_analysis.html">Analysis</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Analysis</h1>

</div>


<head>
<script src="https://kit.fontawesome.com/ece750edd7.js" crossorigin="anonymous"></script>
</head>
<p><br></p>
<div id="assessing-chip-quality" class="section level3">
<h3>10. Assessing ChIP quality</h3>
<p>After we have mapped and filtered the reads it is time to make some
inferences about how good the underlying data is.</p>
<p><br></p>
</div>
<div id="more-scripting" class="section level3">
<h3>More Scripting</h3>
<p>First we want to create a new script for the analysis part of the
exercise and we can save all new commands in here. We’ll start by
creating and opening a new file called <strong>analysis.sh</strong>. The
.sh stands for shell which is essentially just a name for the command
line environment. Here we won’t be using parallel.</p>
<pre class="bash"><code>emacs -nw analysis.sh</code></pre>
<p><strong>Emacs</strong> is a Unix text editor and the -nw flag opens a
new window for editing. Here we are going to paste all of the commands
as we go (click the mouse wheel to paste in the terminal):</p>
<p>The <strong>#</strong> symbol indicates a comment line and anything
proceeded by a # will not be run by the command line. It is good
practice to comment your code. Try adding some comments.</p>
<p>To save and exit the file press <strong>ctrl-x</strong>, followed by
<strong>ctrl-c</strong> and then <strong>y</strong> to save.</p>
<p>Although shell scripts save all of your commands they do not
necessarily track the versions of software that you use or the current
state of your environment and other tool dependencies. More advanced
methods of <em>pipelining</em> and <em>containerisation</em> are
recommended for fully reproducible analysis and sustainable
programming.</p>
<p><br></p>
</div>
<div id="correlation-amongst-samples" class="section level3">
<h3>Correlation amongst samples</h3>
<p>In our experiment there are two replicates, each containing treatment
and input (control) datasets. The first thing we can check is if the
samples are correlated (in other words if treatment and control samples
across the two replicates contain this same kind of signal). To do this
we first generate a read count matrix using <a
href="https://deeptools.readthedocs.io/en/develop/content/tools/multiBamSummary.html">deepTools
multiBamSummary</a>. It will take around 5 minutes to complete so it’s
best to set it running and read on.</p>
<div class="blue">
<pre class="bash"><code>multiBamSummary bins -b bwa_out/*/*uniq.bam -bs 10000 -o cov.matrix -e 200 --smartLabels</code></pre>
</div>
<p>This tool splits the genome into bins of fixed size (10,000 bp in our
example) and computes the number of reads falling within each bin. The
output is in a compressed unreadable format but here is a fragment of
the data produced:</p>
<pre><code>#&#39;chr&#39; &#39;start&#39; &#39;end&#39;  &#39;Reb1_R1&#39;  &#39;Input_R1&#39;  &#39;Input_R1&#39;  &#39;Reb1_R2&#39;
chrVI      0     10000   19.0         41.0         3.0        6.0
chrVI   10000    20000   29.0         30.0        13.0        5.0
chrVI   20000    30000    0.0          0.0         0.0        0.0
chrVI   30000    40000    0.0          2.0         0.0        0.0
chrVI   40000    50000 7447.0        139.0         7.0     2645.0</code></pre>
<p>We can then feed this matrix into <strong>DeepTools
plotCorrelation</strong> to generate a heat map.</p>
<div class="blue">
<pre class="bash"><code>plotCorrelation -in cov.matrix -p heatmap -c spearman -o spearman_cor.png</code></pre>
</div>
<p><img src="images/spearman_cor.png" width=700></p>
<p>Here we can see that treatments (Reb1) and controls (input) correlate
well with each other, while correlation between treatments and controls
is weak. This is a good sign implying that there is reproducible signal
on our data.</p>
<p><br></p>
</div>
<div id="assessing-signal-strength" class="section level3">
<h3>Assessing signal strength</h3>
<p>How do we tell if we have signal coming from ChIP enrichment? One way
of doing this is Signal Extraction Scaling (SES) proposed by <a
href="https://www.degruyter.com/downloadpdf/j/sagmb.2012.11.issue-3/1544-6115.1750/1544-6115.1750.pdf">Diaz:2012</a>.
SES works as follows: Suppose we have two datasets: ChIP and Input DNA.
We divide the genome into N non-overlapping windows and for each window
we compute the number of reads in each sample. We then sort the windows
by the number of reads in 1 sample and plot the cumulative fraction of
reads. We expect Input samples to show approximately equal distribution
of reads across all windows and thus give a flat line, whereas ChIP
samples with very defined enrichments should have a high proportion of
reads in a small number of bins. <a
href="http://deeptools.readthedocs.io/en/latest/">DeepTools</a> provides
a nice explanation of how the success of a ChIP experiment can be judged
based on SES (also called fingerprint) plots:</p>
<p><img src="images/dt_fingerhelp.png" width=700></p>
<p>We can apply this to our own data with <strong>DeepTools
plotFingerprint</strong>:</p>
<div class="blue">
<pre class="bash"><code>plotFingerprint -b bwa_out/*/*uniq.bam -e 200 --smartLabels -o fingerprint.png &amp;</code></pre>
</div>
<p>The fingerprint tool can take a long time to run so we will run in
the background (&amp;) and continue with the tutorial. However, You
should get a plot that looks like the one below where approximately 30%
of the ChIP reads are concentrated in to a small number of bins.</p>
<p><img src="images/dt_fingerplot.png" width=700></p>
<p><br></p>
</div>
<div id="summarizing-chip-signal-enrichment-across-genes"
class="section level3">
<h3>11. Summarizing ChIP signal enrichment across genes</h3>
<p>How many genes contain upstream regions enriched in Reb1 ChIP-seq
reads? This is often represented as a heatmap, here is an example of
histone modification ChIP-seq data from the Deeptools documentation:</p>
<p><img src="images/plotHeatmap_example.png" width=700></p>
<p>First we want to create normalised datasets of ChIP signal vs Input
for our two replicates. This is done using <strong>DeepTools
bamCompare</strong> and gives us a bigWig file of normalised log2
ratios.</p>
<div class="blue">
<pre class="bash"><code>bamCompare -b1 bwa_out/Reb1_R1/Reb1_R1.uniq.bam -b2 bwa_out/Input_R1/Input_R1.uniq.bam -o Reb1_R1.norm.bw -e 200 --operation log2 --normalizeUsing BPM --scaleFactorsMethod None &amp;
bamCompare -b1 bwa_out/Reb1_R2/Reb1_R2.uniq.bam -b2 bwa_out/Input_R2/Input_R2.uniq.bam -o Reb1_R2.norm.bw -e 200 --operation log2 --normalizeUsing BPM --scaleFactorsMethod None &amp;</code></pre>
</div>
<p>The bamCompare tool should take ~5 minutes to complete so you can
move on to the next step. These bigWig files can also be viewed in IGV
so go ahead and link them to the visualisation folder:</p>
<div class="blue">
<pre class="bash"><code>ln -s $PWD/*norm.bw visualisation</code></pre>
</div>
<p>Because we want to plot enrichment around genes we need the gene
annotations. These are already downloaded in the ~genomes folder so
let’s link them to our current directory.</p>
<div class="blue">
<pre class="bash"><code>cp /homes/genomes/s.cerevisiae/sacCer3/annotation/UCSC_sgdGene.bed .</code></pre>
</div>
<p>Take a look at this file:</p>
<pre class="bash"><code>head UCSC_sgdGene.bed</code></pre>
<p>These gene annotations are downloaded from the UCSC website in bed12
format: The co-ordinates are in columns 1-3, the gene name in column 4
and the strand in column 6.</p>
<p>To prepare data necessary for drawing the heatmap we will use <a
href="https://deeptools.readthedocs.io/en/develop/content/tools/computeMatrix.html">deepTools
computeMatrix</a>. Here we supply our normalised datasets as (S)core
files along with the yeast genes from UCSC as the (R)egions to plot. We
are going to compute reads around the TSS in 100b bins, with a 2kb
flanking region either side.</p>
<div class="blue">
<pre class="bash"><code>computeMatrix reference-point -R UCSC_sgdGene.bed -S Reb1_R1.norm.bw Reb1_R2.norm.bw -o TSS.matrix --referencePoint TSS --upstream 2000 --downstream 2000 -bs 100 --smartLabels</code></pre>
</div>
<p>The warning “Skipping Q0010, due to being absent in the computeMatrix
output.” refers to mitochondrial genes and chrM has been exlcuded.</p>
<p>Finally, we can visualize the heatmap by using the <strong>DeepTools
plotHeatmap</strong> tool:</p>
<div class="blue">
<pre class="bash"><code>plotHeatmap -m TSS.matrix -o TSS.heatmap.png </code></pre>
</div>
<p>The resulting image shows that a significant fraction of genes have
peaks of Reb1 enrichment within their upstream regions:</p>
<details>
<summary>
Reveal Plot
</summary>
<div class="solution">
<h2>
<i class="far fa-eye"></i>
</h2>
<p><img src="images/TSS.heatmap.png" width=700></p>
</div>
</details>
<p>It is worth taking a look at the <a
href="http://deeptools.readthedocs.io/en/latest/content/list_of_tools.html">documentation</a>
for the deepTools package in your own time to understand the range of
tools and how different parameters affect your data and the different
plots you can make.</p>
<p><br></p>
</div>
<div id="calling-peaks" class="section level3">
<h3>12. Calling peaks</h3>
<p>While the peaks we have found in the genome browser are pretty clear
and consistent across the two replicates, looking at the entire genome
in the browser is hardly an efficient way to identify all peaks of Reb1
binding. There are several ways to identify genome-wide binding events
and three of these methods are summarised below:</p>
<p><img src="images/peak_finding.jpg" width=700></p>
<p><br></p>
</div>
<div id="macs2" class="section level3">
<h3>MACS2</h3>
<p>In this tutorial we will use the program <a
href="https://github.com/taoliu/MACS">MACS2</a>. MACS2 performs several
steps for calling peaks from paired treatment/control datasets:</p>
<p><img src="images/macs_meth.jpg" width=400></p>
<p>Here is a concise description of these steps:</p>
<ul>
<li><strong>Removing redundancy</strong> - MACS retains uniquely mapped
reads and removes reads that are repeatedly mapped to the same location.
This reduces effects of PCR amplification biases during library
preparation.</li>
<li><strong>Build model and estimate fragment size</strong> - one of the
MACS inputs is the fragment size or bandwidth, which is approximate size
of DNA fragments generated during fragmentation step of library
preparation. MACS first slides a window sized at twice the bandwidth
across the genome and finds instances where read counts enriched by
between 10 and 30 fold relative to the genome background. It then
randomly samples 1,000 of such regions and builds the model. To build
the model it separates reads mapping to each of the strands and builds
two distributions (two modes). The midpoint between the two modes is the
middle of the binding size and the distance between the modes is the
fragment size d (see Figure below).</li>
<li><strong>Generate peaks</strong> - now that d has been defined MACS
slides a window of size 2d across the genome to identify regions
significantly enriched in the ChIP sample. MACS assumes that background
reads obey <a
href="https://en.wikipedia.org/wiki/Poisson_distribution">Poisson
distribution</a>. Thus given the number of reads in a given interval
within the control sample we can calculate the probability of having
observed number of reads in the ChIP sample (e.g., see flood example <a
href="https://en.wikipedia.org/wiki/Poisson_distribution#Examples_of_probability_for_Poisson_distributions">here</a>).
This procedure is performed for several intervals around the examined
location (2d, 1kb, 5kb, 10kb, and the whole genome) and the maximum
value is chosen. One problem with this approach is that it only works if
both samples (ChIP and control) are sequenced to the same depth, which
is not usually happening in practice. To correct this MACS scales down
the larger sample.</li>
<li><strong>Compute False Discovery Rate (FDR)</strong> - <a
href="http://www.nature.com/nprot/journal/v7/n9/full/nprot.2012.101.html">Feng:2012</a>
explains computing FDR in MACS as follows: “When a control sample is
available (and you should really always use it), MACS can also estimate
an empirical FDR for every peak by exchanging the ChIP-seq and control
samples and identifying peaks in the control sample using the same set
of parameters used for the ChIP-seq sample. Because the control sample
should not exhibit read enrichment, any such peaks found by MACS can be
regarded as false positives. For a particular P value threshold, the
empirical FDR is then calculated as the number of control peaks passing
the threshold divided by the number of ChIP-seq peaks passing the same
threshold.”</li>
</ul>
<p><img src="images/macs_peak.png" width=500></p>
<p>Peaks mapped to two strands are treated separately to build two
coverage density profiles - two modes. The distance between the modes is
the fragment size d.</p>
<p><br></p>
</div>
<div id="finding-peaks-with-macs" class="section level3">
<h3>Finding peaks with MACS</h3>
<p>In our case we have two replicates each containing ChIP and input DNA
samples. We will run MACS2 by pooling data (combining two ChIP samples
and two inputs, respectively) but a more stringent approach might be to
run each replicate separately and look for overlapping peaks.</p>
<div class="blue">
<pre class="bash"><code>macs2 callpeak -t bwa_out/Reb1_R1/Reb1_R1.uniq.bam bwa_out/Reb1_R2/Reb1_R2.uniq.bam -c bwa_out/Input_R1/Input_R1.uniq.bam bwa_out/Input_R2/Input_R2.uniq.bam -g 12000000 --nomodel -n Reb1</code></pre>
</div>
<p>The <strong>-g</strong> flag is the approximate genome size for
s.cerevisiae. In this example MACS does not have enough reads to build a
shifting model with our reduced number of reads so we skip this step by
using <strong>–nomodel</strong>. This should be removed when analysing a
complete dataset.</p>
<p>MACS2 will produce three outputs, a peaks.narrowPeak file containing
the co-ordinates of peaks, a peaks.xls file of peaks for excel and a
summits.bed file with the location of the greatest enrichment within
each peak.</p>
<p><br></p>
</div>
<div id="inspecting-peaks" class="section level3">
<h3>Inspecting Peaks</h3>
<p>Looking at MACS2 data we have 816 peaks. Take a look at the peak
calling output, the columns are as follows:</p>
<ol style="list-style-type: decimal">
<li>Chromosome</li>
<li>Start</li>
<li>End</li>
<li>Iterative id given by MACS2</li>
<li>Integer score for display</li>
<li>Strand (irrelevant in this case)</li>
<li>Fold-change (fold enrichment for this peak summit against random
Poisson distribution with local <a
href="https://en.wikipedia.org/wiki/Poisson_distribution">lambda</a>)</li>
<li>log10 P-value (e.g., 17.68 is 1 x 10-17)</li>
<li>log10 Q-value from <a
href="https://en.wikipedia.org/wiki/False_discovery_rate#Benjamini.E2.80.93Hochberg.E2.80.93Yekutieli_procedure">Benjamini–Hochberg–Yekutieli
procedure</a></li>
<li>Relative summit position to peak start</li>
</ol>
<p>You can load the peak files into IGV and see how they correspond to
our bigwig tracks.</p>
<p><img src="images/Peaks.png" width=1200></p>
<p><br></p>
</div>
<div id="what-sequence-motifs-are-found-within-peaks"
class="section level3">
<h3>What sequence motifs are found within peaks?</h3>
<p>In this experiment antibodies against Reb1 protein have been used for
immunoprecipitaion. The recognition site for Reb1 is TTACCCG (<a
href="http://www.sciencedirect.com/science/article/pii/S1097276508008423">Badis:2008</a>).
To find out which sequence motifs are found within our peaks we first
need to convert coordinates into underlying sequences. The <a
href="https://bedtools.readthedocs.io/">bedTools</a> suite has a tool to
do this.</p>
<div class="blue">
<pre class="bash"><code>bedtools getfasta -fi /homes/genomes/s.cerevisiae/sacCer3/sacCer3.fa -bed Reb1_peaks.narrowPeak -fo Reb1_peaks.fasta &amp;</code></pre>
</div>
<p>Now we can run <a href="http://meme-suite.org/">MEME</a> to discover
sequence motifs within our data. The <strong>meme-chip</strong> tool is
designed specifically for looking for motifs in ChIP-seq data:</p>
<div class="blue">
<pre class="bash"><code>meme-chip Reb1_peaks.fasta</code></pre>
</div>
<p>When complete, MEME will create a new folder called
<strong>memechip_out</strong> in your directory and an html (web page)
report. See if you can open this in your web browser and find the
TTACCCG Reb1 binding motif:</p>
<p><img src="images/meme2.png" width=400></p>
<p>Now that we have completed the workshop you should be able to do the
following:</p>
<div class="key-points">
<h2>
<i class="fas fa-thumbtack"></i>Summary:
</h2>
<div id="section" class="section level2">
<h2></h2>
<ul>
<li>Align sequence reads to a reference genome</li>
<li>Assess the quality of your ChIP-seq experiment</li>
<li>Visualise alignments on a genome browser</li>
<li>Summarise ChIP-seq profiles across genes</li>
<li>Peak calling</li>
<li>Motif discovery</li>
<li>Create and run shell scripts</li>
</ul>
</div>
</div>
<p><br></p>
<p>Use these links to download the full <a
href="http://bifx-core.bio.ed.ac.uk/training/ChIP-seq_workshop/pipeline.sh">pipeline.sh</a>
and <a
href="http://bifx-core.bio.ed.ac.uk/training/ChIP-seq_workshop/analysis.sh">analysis.sh</a>
scripts.</p>
<p>If you are interested in other ways to plot or interrogate your data,
the R programming language has many pre-built libraries to specifically
analyse genomic data. Several of these are summarised in our <a
href="http://bifx-core.bio.ed.ac.uk/training/ROI_workshop/R_roi_workshop.html">genomic
regions of interest workshop</a> including gene annotation and plotting
ChIP-seq signals. There are also packages for differential binding and
statistical analysis. R is a very powerful tool for working with genomic
data, applying statistics and creating visualisations. I would highly
recommend learning R if you want to perform further downstream
analyses.</p>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
